<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Polyhydra Vortex Puzzle</title>
<style>
body, html { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#111; font-family:sans-serif; touch-action:none; }
canvas { display:block; }
#ui { position:absolute; top:10px; left:10px; color:#fff; z-index:10; font-size:16px; }
button { margin:5px; padding:10px; border-radius:8px; border:none; cursor:pointer; background:#333; color:#fff; }
button:hover{ background:#555; }
</style>
</head>
<body>
<div id="ui">
  <span id="status">Select Begin tetrahedron</span>
  <button onclick="resetPuzzle()">Reset</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
canvas.width=window.innerWidth; canvas.height=window.innerHeight;

let tetraList=[];
let rotX=0, rotY=0;
const totalTetra=10;
const radius=0.5, heightStep=0.3;

// Puzzle state
let beginTetra=null;
let endTetra=null;
let currentTetra=null;
let visited=[];

// Create vortex tetrahedra
for(let i=0;i<totalTetra;i++){
    let angle=i*(Math.PI/4);
    let z=i*heightStep;
    tetraList.push({
        id:i,
        x: radius*Math.cos(angle),
        y: radius*Math.sin(angle),
        z: z,
        source: i%2===0?"Human":"AI",
        edges:[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]],
        vertices:[
            [0,0,0.1],
            [0.05,0,-0.05],
            [-0.05,0.05,-0.05],
            [-0.05,-0.05,-0.05]
        ],
        neighbors:[], // will define graph edges
    });
}

// Connect tetra sequentially for puzzle graph
for(let i=0;i<totalTetra-1;i++){
    tetraList[i].neighbors.push(tetraList[i+1].id);
    tetraList[i+1].neighbors.push(tetraList[i].id);
}

// ----------------------
// 3D Projection & Rotation
// ----------------------
function rotateXVec([x,y,z],angle){ const c=Math.cos(angle),s=Math.sin(angle); return [x, y*c - z*s, y*s + z*c]; }
function rotateYVec([x,y,z],angle){ const c=Math.cos(angle),s=Math.sin(angle); return [x*c + z*s, y, -x*s + z*c]; }
function project([x,y,z]){ const scale=500; return [canvas.width/2 + x*scale, canvas.height/2 - y*scale]; }

// Draw tetra with puzzle highlights
function drawTetra(t){
    const transformed=t.vertices.map(v=>{
        let vx=v[0]+t.x, vy=v[1]+t.y, vz=v[2]+t.z;
        return rotateYVec(rotateXVec([vx,vy,vz], rotX), rotY);
    });
    let color="#555";
    if(t===beginTetra) color="#0f0";
    else if(t===endTetra) color="#f0f";
    else if(visited.includes(t.id)) color="#ff0";
    else color=t.source==="Human"?"#0a0":"#00a";
    for(const [i,j] of t.edges){
        const [x1,y1]=project(transformed[i]);
        const [x2,y2]=project(transformed[j]);
        ctx.strokeStyle=color;
        ctx.lineWidth=2;
        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.stroke();
    }
}

// Find tetra under mouse
function pickTetra(x,y){
    for(const t of tetraList){
        const tx=project(rotateYVec(rotateXVec([t.x,t.y,t.z], rotX), rotY));
        const dx=x-tx[0], dy=y-tx[1];
        if(Math.sqrt(dx*dx+dy*dy)<30) return t;
    }
    return null;
}

// Animation loop
function draw(){
    ctx.fillStyle="#111";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    tetraList.forEach(t=>drawTetra(t));
    requestAnimationFrame(draw);
}
draw();

// ----------------------
// Touch/Mouse Rotation
// ----------------------
let isDragging=false, lastX=0, lastY=0;
canvas.addEventListener('mousedown', e=>{ isDragging=true; lastX=e.clientX; lastY=e.clientY; });
canvas.addEventListener('mousemove', e=>{
    if(isDragging){
        let dx=e.clientX-lastX, dy=e.clientY-lastY;
        rotY+=dx*0.01; rotX+=dy*0.01;
        lastX=e.clientX; lastY=e.clientY;
    }
});
canvas.addEventListener('mouseup', e=>isDragging=false);
canvas.addEventListener('mouseleave', e=>isDragging=false);

canvas.addEventListener('touchstart', e=>{ isDragging=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; });
canvas.addEventListener('touchmove', e=>{ e.preventDefault(); if(isDragging){ let dx=e.touches[0].clientX-lastX, dy=e.touches[0].clientY-lastY; rotY+=dx*0.01; rotX+=dy*0.01; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; } });
canvas.addEventListener('touchend', e=>isDragging=false);

// ----------------------
// Puzzle Click / Touch
// ----------------------
canvas.addEventListener('click', e=>{
    const t=pickTetra(e.clientX,e.clientY);
    if(!t) return;
    if(!beginTetra){
        beginTetra=t;
        currentTetra=t;
        endTetra=tetraList[tetraList.length-1];
        document.getElementById('status').innerText="Navigate to End (magenta)";
        visited.push(t.id);
    } else if(currentTetra.neighbors.includes(t.id) && !visited.includes(t.id)){
        currentTetra=t;
        visited.push(t.id);
        if(currentTetra===endTetra){
            document.getElementById('status').innerText="Puzzle Complete! ðŸŽ‰";
        }
    }
});

// ----------------------
// Reset
// ----------------------
function resetPuzzle(){
    beginTetra=null;
    endTetra=null;
    currentTetra=null;
    visited=[];
    document.getElementById('status').innerText="Select Begin tetrahedron";
}

// ----------------------
// Responsive Canvas
// ----------------------
window.addEventListener('resize', ()=>{canvas.width=window.innerWidth; canvas.height=window.innerHeight;});
</script>
</body>
</html>
