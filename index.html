</<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Polyhydra Vortex Puzzle Game</title>
<style>
body, html { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#111; font-family:'Arial Black', sans-serif; touch-action:none; }
canvas { display:block; }
#ui { position:absolute; top:20px; left:50%; transform:translateX(-50%); display:flex; flex-direction:column; align-items:center; z-index:10; color:#fff; }
#status { font-size:36px; margin-bottom:20px; text-align:center; color:#0f0; text-shadow:2px 2px 10px #000; }
button { font-size:28px; padding:15px 40px; margin:10px; border:none; border-radius:15px; cursor:pointer; background: linear-gradient(#222,#555); color:#fff; text-shadow:1px 1px 2px #000; transition:0.2s; }
button:hover { background: linear-gradient(#555,#222); }
#leaderboard { margin-top:20px; font-size:24px; color:#ff0; text-align:center; }
input[type="text"]{ font-size:24px; padding:5px 10px; border-radius:10px; border:none; margin-top:10px; }
</style>
</head>
<body>
<div id="ui">
    <div id="status">Select Begin Tetrahedron</div>
    <button id="resetBtn">Restart Game</button>
    <div id="leaderboard">
        <div>üèÜ Leaderboard üèÜ</div>
        <div id="entries">No submissions yet</div>
        <input type="text" id="playerName" placeholder="Your Name"/>
        <button id="submitBtn">Submit Score</button>
    </div>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
canvas.width=window.innerWidth; canvas.height=window.innerHeight;

// ----------------------
// Polyhydra Vortex Setup
// ----------------------
let tetraList=[];
let rotX=0, rotY=0;
const totalTetra=10;
const radius=0.5, heightStep=0.3;

// Puzzle state
let beginTetra=null;
let endTetra=null;
let currentTetra=null;
let visited=[];
let moveCount=0;

// Leaderboard (persistent)
let leaderboard=JSON.parse(localStorage.getItem('vortexLeaderboard')) || [];

// Create vortex tetrahedra
for(let i=0;i<totalTetra;i++){
    let angle=i*(Math.PI/4);
    let z=i*heightStep;
    tetraList.push({
        id:i,
        x: radius*Math.cos(angle),
        y: radius*Math.sin(angle),
        z: z,
        source: i%2===0?"Human":"AI",
        edges:[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]],
        vertices:[
            [0,0,0.1],
            [0.05,0,-0.05],
            [-0.05,0.05,-0.05],
            [-0.05,-0.05,-0.05]
        ],
        neighbors:[],
    });
}

// Connect tetra sequentially
for(let i=0;i<totalTetra-1;i++){
    tetraList[i].neighbors.push(tetraList[i+1].id);
    tetraList[i+1].neighbors.push(tetraList[i].id);
}

// ----------------------
// 3D Projection & Rotation
// ----------------------
function rotateXVec([x,y,z],angle){ const c=Math.cos(angle),s=Math.sin(angle); return [x, y*c - z*s, y*s + z*c]; }
function rotateYVec([x,y,z],angle){ const c=Math.cos(angle),s=Math.sin(angle); return [x*c + z*s, y, -x*s + z*c]; }
function project([x,y,z]){ const scale=500; return [canvas.width/2 + x*scale, canvas.height/2 - y*scale]; }

// Draw tetra with highlights
function drawTetra(t){
    const transformed=t.vertices.map(v=>{
        let vx=v[0]+t.x, vy=v[1]+t.y, vz=v[2]+t.z;
        return rotateYVec(rotateXVec([vx,vy,vz], rotX), rotY);
    });
    let color="#555";
    if(t===beginTetra) color="#0f0";
    else if(t===endTetra) color="#f0f";
    else if(visited.includes(t.id)) color="#ff0";
    else color=t.source==="Human"?"#0a0":"#00a";
    for(const [i,j] of t.edges){
        const [x1,y1]=project(transformed[i]);
        const [x2,y2]=project(transformed[j]);
        ctx.strokeStyle=color;
        ctx.lineWidth=2;
        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.stroke();
    }
}

// Pick tetrahedron under pointer
function pickTetra(x,y){
    for(const t of tetraList){
        const tx=project(rotateYVec(rotateXVec([t.x,t.y,t.z], rotX), rotY));
        const dx=x-tx[0], dy=y-tx[1];
        if(Math.sqrt(dx*dx+dy*dy)<30) return t;
    }
    return null;
}

// Animation loop
function draw(){
    ctx.fillStyle="#111";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    tetraList.forEach(t=>drawTetra(t));
    requestAnimationFrame(draw);
}
draw();

// ----------------------
// Rotation controls
// ----------------------
let isDragging=false, lastX=0, lastY=0;
canvas.addEventListener('mousedown', e=>{ isDragging=true; lastX=e.clientX; lastY=e.clientY; });
canvas.addEventListener('mousemove', e=>{ if(isDragging){ let dx=e.clientX-lastX, dy=e.clientY-lastY; rotY+=dx*0.01; rotX+=dy*0.01; lastX=e.clientX; lastY=e.clientY; }});
canvas.addEventListener('mouseup', e=>isDragging=false);
canvas.addEventListener('mouseleave', e=>isDragging=false);

canvas.addEventListener('touchstart', e=>{ isDragging=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; });
canvas.addEventListener('touchmove', e=>{ e.preventDefault(); if(isDragging){ let dx=e.touches[0].clientX-lastX, dy=e.touches[0].clientY-lastY; rotY+=dx*0.01; rotX+=dy*0.01; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; } });
canvas.addEventListener('touchend', e=>isDragging=false);

// ----------------------
// Puzzle Click
// ----------------------
canvas.addEventListener('click', e=>{
    const t=pickTetra(e.clientX,e.clientY);
    if(!t) return;
    if(!beginTetra){
        beginTetra=t;
        currentTetra=t;
        endTetra=tetraList[tetraList.length-1];
        visited.push(t.id);
        moveCount=0;
        document.getElementById('status').innerText="Navigate to Magenta End!";
    } else if(currentTetra.neighbors.includes(t.id) && !visited.includes(t.id)){
        currentTetra=t;
        visited.push(t.id);
        moveCount++;
        if(currentTetra===endTetra){
            document.getElementById('status').innerText=`üéâ Puzzle Complete in ${moveCount} moves! Enter Name to Submit`;
        }
    }
});

// ----------------------
// Reset
// ----------------------
function resetPuzzle(){
    beginTetra=null;
    endTetra=null;
    currentTetra=null;
    visited=[];
    moveCount=0;
    document.getElementById('status').innerText="Select Begin Tetrahedron";
}

// ----------------------
// Leaderboard
// ----------------------
function updateLeaderboardUI(){
    const entries=document.getElementById('entries');
    entries.innerHTML=leaderboard.slice(0,5).map((e,i)=>`${i+1}. ${e.name} - ${e.moves} moves`).join('<br>') || "No submissions yet";
}
updateLeaderboardUI();

document.getElementById('submitBtn').addEventListener('click', ()=>{
    const name=document.getElementById('playerName').value || "Anonymous";
    if(currentTetra!==endTetra) return;
    leaderboard.push({name:name,moves:moveCount});
    leaderboard.sort((a,b)=>a.moves-b.moves);
    localStorage.setItem('vortexLeaderboard', JSON.stringify(leaderboard));
    updateLeaderboardUI();
    document.getElementById('playerName').value="";
});

document.getElementById('resetBtn').addEventListener('click', resetPuzzle);

// Responsive canvas
window.addEventListener('resize', ()=>{canvas.width=window.innerWidth; canvas.height=window.innerHeight;});
</script>
</body>
</html>
