<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>The Skins Game</title>
<link rel="icon" type="image/x-icon" href="IMG_0153.jpeg">

<!-- Modern fonts -->
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet">

<style>
* {
    box-sizing: border-box;
}

body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background:
        radial-gradient(circle at top, #202844 0, #050814 45%, #020308 100%);
    font-family: 'Space Grotesk', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    touch-action: none;
    color: #fff;
}

/* Canvas always full screen */
canvas {
    display: block;
}

/* Center UI panel */
#ui {
    position: absolute;
    top: 24px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 10;
    max-width: 90%;
    padding: 18px 26px;
    border-radius: 20px;

    /* Glassmorphism */
    background: rgba(7, 15, 30, 0.7);
    border: 1px solid rgba(0, 234, 255, 0.25);
    backdrop-filter: blur(14px);
    -webkit-backdrop-filter: blur(14px);
    box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.6),
        0 0 30px rgba(0, 234, 255, 0.4);
}

#status {
    font-size: 32px;
    margin-bottom: 16px;
    text-align: center;
    color: #00eaff;
    font-weight: 700;
    letter-spacing: 0.04em;
    text-shadow: 0 0 14px rgba(0, 234, 255, 0.9);
}

/* Primary buttons */
button {
    font-size: 18px;
    padding: 12px 26px;
    margin: 4px;
    border: none;
    border-radius: 14px;
    cursor: pointer;
    font-weight: 600;
    letter-spacing: 0.03em;

    background: linear-gradient(135deg, #00eaff, #007bff);
    color: #fdfdfd;
    box-shadow:
        0 0 12px rgba(0, 234, 255, 0.7),
        0 10px 20px rgba(0, 0, 0, 0.7);
    transition:
        transform 0.22s ease,
        box-shadow 0.22s ease,
        background 0.22s ease,
        opacity 0.2s ease;
}

button:hover {
    transform: translateY(-3px) translateZ(0);
    box-shadow:
        0 0 20px rgba(0, 234, 255, 1),
        0 16px 28px rgba(0, 0, 0, 0.75);
    background: linear-gradient(135deg, #4df7ff, #3393ff);
}

button:active {
    transform: translateY(0);
    box-shadow:
        0 0 10px rgba(0, 234, 255, 0.8),
        0 8px 18px rgba(0, 0, 0, 0.8);
    opacity: 0.9;
}

/* Cheat Sheet Toggle Button (bottom-left) */
#toggleCheatBtn {
    position: absolute;
    bottom: 20px;
    left: 20px;
    z-index: 10;

    font-size: 15px;
    padding: 10px 18px;
    border-radius: 999px;

    background: linear-gradient(135deg, #ff4df0, #7a3cff);
    box-shadow:
        0 0 14px rgba(255, 77, 240, 0.9),
        0 10px 24px rgba(0, 0, 0, 0.85);
}

/* Cheat Sheet Card */
#cheatsheet {
    position: absolute;
    bottom: 70px;
    left: 20px;
    z-index: 10;
    max-width: 240px;
    padding: 18px 18px 14px 18px;
    border-radius: 18px;

    background: rgba(4, 10, 24, 0.82);
    border: 1px solid rgba(0, 234, 255, 0.35);
    box-shadow:
        0 0 26px rgba(0, 234, 255, 0.6),
        0 16px 32px rgba(0, 0, 0, 0.9);

    font-size: 13px;
    line-height: 1.4;
    display: none;
    animation: fadeIn 0.25s ease-out;
}

#cheatsheet h3 {
    margin: 0 0 10px 0;
    font-size: 15px;
    text-align: center;
    color: #00eaff;
    text-shadow: 0 0 8px rgba(0, 234, 255, 0.8);
    letter-spacing: 0.05em;
}

#cheatsheet p {
    margin: 4px 0;
}

#cheatsheet hr {
    border: none;
    border-top: 1px solid rgba(0, 234, 255, 0.4);
    margin: 10px 0;
}

/* Animations */
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(5px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Responsive adjustments */
@media (max-width: 600px) {
    #ui {
        top: 14px;
        padding: 14px 16px;
    }
    #status {
        font-size: 22px;
    }
    button {
        font-size: 15px;
        padding: 9px 18px;
    }
    #toggleCheatBtn {
        font-size: 13px;
        padding: 8px 14px;
        bottom: 16px;
        left: 14px;
    }
    #cheatsheet {
        bottom: 60px;
        left: 14px;
        max-width: 210px;
    }
}

@media (min-width: 601px) and (max-width: 1200px) {
    #status { font-size: 28px; }
    button { font-size: 17px; padding: 10px 22px; }
}

@media (min-width: 1201px) {
    #status { font-size: 34px; }
    button { font-size: 18px; padding: 12px 26px; }
}

    .logo-wrap {
    position: absolute;
    top: 18px;
    left: 22px;
    z-index: 20;
    display: flex;
    align-items: center;
    pointer-events: none; /* logo doesn't block clicks/drags */
}

.logo-wrap img {
    height: 70px;
    filter:
        drop-shadow(0 0 10px rgba(0, 255, 138, 0.8))
        drop-shadow(0 0 24px rgba(0, 255, 138, 0.45));
}

/* Smaller on mobile */
@media (max-width: 600px) {
    .logo-wrap img {
        height: 52px;
    }
}

</style>
</head>

<body>
    <div class="logo-wrap">
  <img src="skins-game-text.svg" alt="Skins Game logo">
</div>

<div id="ui">
    <div id="status">Select Begin Star</div>
    <div>
        <button id="resetBtn">Restart Game</button>
    </div>
</div>

<!-- Cheat Sheet Toggle Button -->
<button id="toggleCheatBtn">Show Cheat Sheet</button>

<!-- Cheat Sheet Overlay -->
<div id="cheatsheet">
    <h3>‚≠ê CHEAT SHEET ‚≠ê</h3>
    <p><span style="color:#f0f;">‚òÖ</span> Begin Star</p>
    <p><span style="color:#ff5500;">‚òÖ</span> End Star</p>
    <p><span style="color:#ffeb3b;">‚òÖ</span> Human Star</p>
    <p><span style="color:#00eaff;">‚òÖ</span> AI Star</p>
    <p><span style="color:#54ff9f;">‚òÖ</span> Visited Star</p>
    <hr>
    <p><strong>Controls</strong></p>
    <p>Drag / Touch ‚Üí Rotate Vortex</p>
    <p>Mouse Wheel / Pinch ‚Üí Zoom</p>
    <p>Click / Tap ‚Üí Select Star</p>
    <p>‚ÄúRestart Game‚Äù ‚Üí Reset Puzzle</p>
</div>

<canvas id="canvas"></canvas>

<script>
// ================================
// Cheat Sheet Toggle
// ================================
const cheatBtn = document.getElementById('toggleCheatBtn');
const cheatDiv = document.getElementById('cheatsheet');
let cheatVisible = false;

cheatBtn.addEventListener('click', () => {
    cheatVisible = !cheatVisible;
    cheatDiv.style.display = cheatVisible ? 'block' : 'none';
    cheatBtn.innerText = cheatVisible ? 'Hide Cheat Sheet' : 'Show Cheat Sheet';
});

// ================================
// Canvas + Game Logic
// ================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Zoom configuration (start at most zoomed out)
const MIN_SCALE = 140;
const MAX_SCALE = 2000;
let scaleFactor = MIN_SCALE;   // most zoomed-out to start

// Auto-rotate
const AUTO_ROTATE_SPEED = 0.25; // degrees per second around Y
let lastTime = 0;

// Star Vortex Setup
let starList = [];
let rotX = 0, rotY = 0;

const totalStars = 10;
const radius = 0.5;
const heightStep = 0.3;

// Puzzle state
let beginStar = null;
let endStar = null;
let currentStar = null;
let visited = [];
let moveCount = 0;

// Neon color scheme
const colors = {
    human: "#ffeb3b",     // yellow
    ai: "#00eaff",        // neon cyan
    begin: "#f0f",        // magenta
    end: "#ff5500",       // orange
    visited: "#54ff9f",   // light neon green
    path: "#54ff9f"
};

// Background starfield
const bgStars = [];
function initBgStars() {
    bgStars.length = 0;
    const count = 140;
    for (let i = 0; i < count; i++) {
        bgStars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            r: Math.random() * 1.7 + 0.3,
            speed: Math.random() * 0.15 + 0.02,
            alpha: Math.random() * 0.4 + 0.2
        });
    }
}
initBgStars();

// Create star vortex
for (let i = 0; i < totalStars; i++) {
    let angle = i * (Math.PI / 4);
    let z = i * heightStep;
    starList.push({
        id: i,
        x: radius * Math.cos(angle),
        y: radius * Math.sin(angle),
        z: z,
        edges: [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]],
        vertices: [
            [0, 0, 0.1],
            [0.05, 0, -0.05],
            [-0.05, 0.05, -0.05],
            [-0.05, -0.05, -0.05]
        ],
        neighbors: [],
        type: i % 2 === 0 ? "human" : "ai"
    });
}

// Connect stars sequentially
for (let i = 0; i < totalStars - 1; i++) {
    starList[i].neighbors.push(starList[i + 1].id);
    starList[i + 1].neighbors.push(starList[i].id);
}

// 3D helpers
function rotateXVec([x, y, z], angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    return [x, y * c - z * s, y * s + z * c];
}
function rotateYVec([x, y, z], angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    return [x * c + z * s, y, -x * s + z * c];
}
function project([x, y, z]) {
    return [
        canvas.width / 2 + x * scaleFactor,
        canvas.height / 2 - y * scaleFactor
    ];
}

// Draw background stars
function drawBgStars() {
    ctx.save();
    ctx.fillStyle = "#050814";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (const s of bgStars) {
        s.y += s.speed;
        if (s.y > canvas.height + 5) {
            s.y = -5;
            s.x = Math.random() * canvas.width;
        }
        ctx.globalAlpha = s.alpha;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fillStyle = "#ffffff";
        ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
}

// ================================
// Particle system
// ================================
const particles = [];

function spawnBurst(x, y, color, power = 1) {
    const count = 20 + Math.floor(20 * power);
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = (60 + Math.random() * 120) * power;
        particles.push({
            x,
            y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.6 + Math.random() * 0.5,
            age: 0,
            size: 2 + Math.random() * 2,
            color
        });
    }
}

function updateAndDrawParticles(dt) {
    if (!particles.length) return;

    ctx.save();
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.age += dt;
        if (p.age >= p.life) {
            particles.splice(i, 1);
            continue;
        }
        const t = p.age / p.life;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 40 * dt * 0.2; // tiny gravity-ish pull

        const alpha = 1 - t;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * (1 - t * 0.4), 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
}

// Draw a single star (3D edges + glowing icon)
function drawStar(s, t) {
    const transformed = s.vertices.map(v => {
        let vx = v[0] + s.x;
        let vy = v[1] + s.y;
        let vz = v[2] + s.z;
        return rotateYVec(rotateXVec([vx, vy, vz], rotX), rotY);
    });

    // Depth factor based on average z
    const avgZ = transformed.reduce((acc, v) => acc + v[2], 0) / transformed.length;
    const depthFactor = 1 - Math.min(Math.max((avgZ / (totalStars * heightStep * 1.2)), 0), 0.9);

    let color = colors[s.type];
    if (s === beginStar) color = colors.begin;
    else if (s === endStar) color = colors.end;
    else if (visited.includes(s.id)) color = colors.visited;

    // Soft lines with depth
    ctx.lineWidth = 1.5 + depthFactor * 1.2;
    ctx.strokeStyle = color;
    ctx.globalAlpha = 0.5 + depthFactor * 0.4;
    for (const [i, j] of s.edges) {
        const [x1, y1] = project(transformed[i]);
        const [x2, y2] = project(transformed[j]);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Draw star icon with pulsation
    const rotatedCenter = rotateYVec(rotateXVec([s.x, s.y, s.z], rotX), rotY);
    const [cx, cy] = project(rotatedCenter);

    let basePulse = 1 + 0.06 * Math.sin(t * 4 + s.id);
    if (s === beginStar || s === endStar) {
        basePulse = 1 + 0.18 * Math.sin(t * 4 + s.id);
    }

    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(basePulse, basePulse);
    ctx.shadowColor = color;
    ctx.shadowBlur = 28;
    ctx.fillStyle = color;
    ctx.font = "28px 'Space Grotesk', system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("‚òÖ", 0, 1);
    ctx.restore();
}

// Draw the visited path as a separate glowing line
function drawVisitedPath() {
    if (visited.length < 2) return;

    ctx.save();
    ctx.lineWidth = 4;
    ctx.strokeStyle = colors.path;
    ctx.shadowColor = colors.path;
    ctx.shadowBlur = 25;

    ctx.beginPath();
    for (let i = 0; i < visited.length - 1; i++) {
        const sA = starList.find(s => s.id === visited[i]);
        const sB = starList.find(s => s.id === visited[i + 1]);
        if (!sA || !sB) continue;

        const cA = project(rotateYVec(rotateXVec([sA.x, sA.y, sA.z], rotX), rotY));
        const cB = project(rotateYVec(rotateXVec([sB.x, sB.y, sB.z], rotX), rotY));

        if (i === 0) {
            ctx.moveTo(cA[0], cA[1]);
        }
        ctx.lineTo(cB[0], cB[1]);
    }
    ctx.stroke();
    ctx.restore();
}

// Picking logic (for clicks/taps)
function pickStar(x, y) {
    for (const s of starList) {
        const rotated = rotateYVec(rotateXVec([s.x, s.y, s.z], rotX), rotY);
        const [sx, sy] = project(rotated);
        const dx = x - sx;
        const dy = y - sy;
        if (Math.sqrt(dx * dx + dy * dy) < 30) return s;
    }
    return null;
}

// Animation loop with auto-rotate + particles
function drawFrame(timestamp) {
    const t = timestamp * 0.001;
    const dt = lastTime ? (timestamp - lastTime) / 1000 : 0;
    lastTime = timestamp;

    // auto-rotate slowly around Y axis (degrees ‚Üí radians)
    const autoDelta = (AUTO_ROTATE_SPEED * Math.PI / 180) * dt;
    rotY += autoDelta;

    drawBgStars();

    // Draw stars from back to front
    const sorted = [...starList].sort((a, b) => {
        const ra = rotateYVec(rotateXVec([a.x, a.y, a.z], rotX), rotY)[2];
        const rb = rotateYVec(rotateXVec([b.x, b.y, b.z], rotX), rotY)[2];
        return ra - rb;
    });

    for (const s of sorted) {
        drawStar(s, t);
    }

    drawVisitedPath();
    updateAndDrawParticles(dt);

    requestAnimationFrame(drawFrame);
}
requestAnimationFrame(drawFrame);

// Rotation + zoom controls
let isDragging = false;
let lastX = 0, lastY = 0;
let lastDistance = null;

// Mouse
canvas.addEventListener('mousedown', e => {
    isDragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
});

canvas.addEventListener('mousemove', e => {
    if (isDragging) {
        let dx = e.clientX - lastX;
        let dy = e.clientY - lastY;
        rotY += dx * 0.01;
        rotX += dy * 0.01;
        lastX = e.clientX;
        lastY = e.clientY;
    }
});

canvas.addEventListener('mouseup', () => { isDragging = false; });
canvas.addEventListener('mouseleave', () => { isDragging = false; });

// Wheel zoom
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    scaleFactor *= e.deltaY < 0 ? 1.1 : 0.9;
    if (scaleFactor < MIN_SCALE) scaleFactor = MIN_SCALE;
    if (scaleFactor > MAX_SCALE) scaleFactor = MAX_SCALE;
});

// Touch (single = rotate, double = pinch zoom)
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
        isDragging = true;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
    }
    if (e.touches.length === 2) {
        isDragging = false;
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastDistance = Math.sqrt(dx * dx + dy * dy);
    }
});

canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 1) {
        e.preventDefault();
        if (isDragging) {
            let dx = e.touches[0].clientX - lastX;
            let dy = e.touches[0].clientY - lastY;
            rotY += dx * 0.01;
            rotX += dy * 0.01;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        }
    } else if (e.touches.length === 2) {
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (lastDistance != null) {
            const zoom = distance / lastDistance;
            scaleFactor *= zoom;
            if (scaleFactor < MIN_SCALE) scaleFactor = MIN_SCALE;
            if (scaleFactor > MAX_SCALE) scaleFactor = MAX_SCALE;
        }
        lastDistance = distance;
    }
});

canvas.addEventListener('touchend', e => {
    if (e.touches.length === 0) {
        isDragging = false;
        lastDistance = null;
    } else if (e.touches.length === 1) {
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
        lastDistance = null;
    }
});

// Puzzle click/tap with particle bursts
canvas.addEventListener('click', e => {
    const s = pickStar(e.clientX, e.clientY);
    if (!s) return;

    const statusEl = document.getElementById('status');

    // Compute screen position for particle burst
    const rotated = rotateYVec(rotateXVec([s.x, s.y, s.z], rotX), rotY);
    const [sx, sy] = project(rotated);

    if (!beginStar) {
        beginStar = s;
        currentStar = s;
        endStar = starList[starList.length - 1];
        visited = [s.id];
        moveCount = 0;
        statusEl.innerText = "Navigate to Magenta End!";

        // burst at begin star
        spawnBurst(sx, sy, colors.begin, 1.1);
    } else if (currentStar.neighbors.includes(s.id) && !visited.includes(s.id)) {
        currentStar = s;
        visited.push(s.id);
        moveCount++;

        // normal move burst
        let burstColor = colors[s.type];
        if (visited.includes(s.id)) burstColor = colors.visited;
        spawnBurst(sx, sy, burstColor, 0.8);

        if (currentStar === endStar) {
            statusEl.innerText = `üéâ Puzzle complete in ${moveCount} moves!`;

            // big celebratory burst at end star
            spawnBurst(sx, sy, colors.end, 1.8);
        }
    }
});

// Reset button
document.getElementById('resetBtn').addEventListener('click', () => {
    beginStar = null;
    endStar = null;
    currentStar = null;
    visited = [];
    moveCount = 0;
    scaleFactor = MIN_SCALE; // back to zoomed-out
    document.getElementById('status').innerText = "Select Begin Star";
});

// Resize handling
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    initBgStars();
});
</script>
</body>
</html>
